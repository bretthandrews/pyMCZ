import numpy as np
import matplotlib.pyplot as plt
import matplotlib.mlab as mlab
import scipy.stats.mstats as ssm
import metalicity

##############################################################################
##############################################################################
##The function calculation is a translation of abundance_err_min/med/max.pro
##IDL codes by Lisa.
##This code takes the min,med,and max flux files and then samples n fluxes
##from a gaussian generated by the fluxes and their errors. The resulting
##metalicities are saved as histograms.
##############################################################################

##############################################################################
##Reads the flux file and returns it as an array.
##Ignores non-numeric lines
##Returns  (flux array,num)
##############################################################################
def readfile(filename):
    a=open(filename,'r')
    b=np.array([])
    i=0
    j=0
    for line in a:
        try:
            strs=np.array(line.rstrip('\n').split()).astype(np.float)
            i=strs.size
            b=np.append(b,strs,axis=0)
            j+=1
        except ValueError:
            continue
    b.resize(j,i)
    b=np.transpose(b)
    a.close()
    return b,j
##############################################################################
##a simple gaussian
##############################################################################
def gaussian(x,m,s):
    return 1./(s*np.sqrt(2*np.pi)) * np.exp(-(x-m)**2 /(2 *s**2))

##############################################################################
##returns appropriate bin size for the number of data
##mode 'd' calculates this based on Doane's formula (default)
##mode 's' calculates this based on sqrt of number of data
##mode 't' calculates this based on s*n**1/3
##############################################################################
def getbinsize(n,data,mode='t'):
    if mode=='d':
        g1=ssm.moment(data,moment=3)
        s1=np.sqrt(6.*(n-2.)/((n+1.)*(n+3.)))
        k=1+np.log2(n)+np.log2(1+np.abs(g1/s1))
    elif mode=='s':
        k=np.sqrt(n)
    elif mode=='t':
        k=2.*n**(1./3.)
    return k

##############################################################################
##Save the result as histogram as name
## delog - if true de-logs the data. False by default
##############################################################################
def savehist(data,name,delog=False,mode='t'):
    plt.clf()
    
    ###de-log###
    if delog==True:
        data=np.power(10,np.absolute(data-12))
        
    data=np.sort(data)
    data=data[np.where(np.isfinite(data)==True)]
    
    ####kill outliers###
    mean=np.mean(data)
    std=np.std(data)
    data=data[np.where(data>mean-5*std)]
    data=data[np.where(data<mean+5*std)]
    n=data.shape[0]
    if data.shape[0]<=0:
        print name,'is blank'
        return
    

    try:
        ######find fit and save hist######

        ###find appropriate bin size###
        numbin=getbinsize(data.shape[0],data,mode)
        

        ###make hist###
        count, bins, ignored = plt.hist(data, numbin, normed=1.0)

        ###find error###
        l,r,t,fl,fr=err_est(count)
        y=np.zeros(len(bins))
        left=bins[l]+(bins[l+1]-bins[l])*fl
        right=bins[r]-(bins[r]-bins[r-1])*fr
        
        ###plot hist###
        plt.plot(bins,y)
        plt.axvspan(left,right,color='red',alpha=0.4)
        st='n=%d\nconfidence: %f\nleft: %f\nright: %f'%(n,t,left,right)
        plt.annotate(st, xy=(0.70, 0.80), xycoords='axes fraction')
        plt.title(name)
        if delog==True:
            #plt.ylim(0,1)
            plt.xlabel('O/H')
        else:
            plt.xlabel('12+log(O/H)')
        plt.ylabel('counts')
        plt.savefig(name+'.png')

        ###print out the confidence interval###
        print name, ':\t%f +- %f'%((left+right)/2.,(right-left)/2.)

    except (OverflowError,AttributeError,ValueError):
        print data
        print name, 'had infinities'
##############################################################################        
##almost (symmetric) method
##estimating error starting at the peak.
##almost (symmetric) - make it go same l and r
##not well behaved in case of multiple peaks
##code not up to date(oct 21 2013)
##############################################################################        
def err_est1(count,prob=0.68):
    peak=np.argmax(count)
    total=np.sum(count)
    temp=0
    l=0
    r=0
    while temp<total*prob:
        if count[peak-l]>=count[peak+r]:
            temp+=count[peak-l]
            l+=1
        else:
            temp+=count[peak+r]
            r+=1

    return peak-l,peak-r,(total-temp)/total,0,0

##############################################################################
##(central) method
#estmating error starting from the ends.
##input: 'count' returned from plt.hist, 'prob' default 68%
##output: the index of left boundary, right boundary, confidence,
#fraction to be shifted to left, fraction to be shifted from the right
##############################################################################
def err_est(count,prob=0.68):
    total=np.sum(count)
    l=0
    fl=0.
    r=len(count)-1
    fr=0.
    ltemp=count[l]
    rtemp=count[r]
    
    thresh=total*(1.-prob)/2.
    while ltemp<=thresh:
        l+=1
        ltemp+=count[l]
        if ltemp>thresh:
            ltemp-=count[l]
            fl=(thresh-ltemp)/count[l]   
            l-=1
            break
    while rtemp<=thresh:
        r-=1
        rtemp+=count[r]
        if rtemp>thresh:
            rtemp-=count[r]
            fr=(thresh-rtemp)/count[r]
            r+=1
            break
    return l,r,(total-2*thresh)/total,fl,1-fr    
    
    

##############################################################################
##The main function. takes max,med,min fluxes as input. The files should have
##the name format of filename_max.txt, filename_med.txt, and filename_min.txt
## filename - a string 'filename' common to the three flux files
## nsample - the number of samples the code will generate. Default is 100
## saveres - will make the code save all results of each iterations. Default True
## dl - enable de-logging of the result. Default is False
##############################################################################
def main(filename,nsample=100,errmode='t',saveres=True,dl=False):
    ###Initialize###
    maxfile=filename+"_max.txt"
    medfile=filename+"_med.txt"
    minfile=filename+"_min.txt"
    outfile=filename+"_res_n%d.txt"%nsample
    
    ###initialize the saveres txt file###
    if saveres==True:
        of=open(outfile,'w')
        of.write('')
        of.close()

    ###read the max, med, min flux files###    
    maxf,nm=readfile(maxfile)
    medf,num=readfile(medfile)
    minf,nn=readfile(minfile)

    ###calculate the error as 1/2 [(max-med)+(med-min)]###
    err=0.5*((maxf-medf)+(medf-minf))


    ####Sample 'nsample' points from a gaussian###
    mu=0
    sigma=1
    sample=np.random.normal(mu,sigma,nsample)
    
    ###save this sampled gaussians into a png file###
    count, bins, ignored = plt.hist(sample, 40,normed=1)
    plt.plot(bins,gaussian(bins,mu,sigma))
    plt.title("Sampled")
    st="n=%d"%nsample
    plt.annotate(st, xy=(0.70, 0.85), xycoords='axes fraction')
    plt.savefig(filename+'_n%d_sample.png'%nsample)
    plt.clf()

    
    ###Start calculation###
    print "Starting iteration"
    res=[]
    for i in range(len(sample)):
        ##the flux to be feed to the calculation will be
        ##medf + error*i, where i is the sampled gaussian
        temp=medf+err*sample[i]

        t=metalicity.calculation(temp,nm,outfile,red_corr=True,saveres=saveres)

        res.append(t)
    result=np.array(res)
    print "Iteration Complete"
    print result.shape
    for i in range(result.shape[2]):
    ###Save the results as a histogram.###
        savehist(result[:,0,i],filename+'_n%d_KD_comb_NEW_i%d'%(nsample,i),dl,errmode)
        savehist(result[:,1,i],filename+'_n%d_KD02_NIIOII_i%d'%(nsample,i),dl,errmode)
        savehist(result[:,2,i],filename+'_n%d_KD03new_abund_R23_i%d'%(nsample,i),dl,errmode)
        savehist(result[:,3,i],filename+'_n%d_M91_i%d'%(nsample,i),dl,errmode)
        savehist(result[:,4,i],filename+'_n%d_Z94_i%d'%(nsample,i),dl,errmode)
        savehist(result[:,5,i],filename+'_n%d_KD03_NIIHa_abund_i%d'%(nsample,i),dl,errmode)
        savehist(result[:,6,i],filename+'_n%d_D02_i%d'%(nsample,i),dl,errmode)
        savehist(result[:,7,i],filename+'_n%d_PP04_N2_i%d'%(nsample,i),dl,errmode)
        savehist(result[:,8,i],filename+'_n%d_PP04_O3N2_i%d'%(nsample,i),dl,errmode)
        print "---------------------------------------------"
    print "Save hist complete"
##############################################################################
##############################################################################    
#### How to Use this code:
##############################################################################    
##############################################################################    
####example) if you have:
####     sn2006ss_max.txt
####     sn2006ss_med.txt
####     sn2006ss_min.txt
####
####     and you want to sample 5000 points
####     do:
####
#### filename="sn2006ss"
#### nsample=5000
####
##############################################################################
####Just edit this part to use
##############################################################################

filename="sn2006ss"
nsample=50000

##############################################################################
main(filename,nsample)
